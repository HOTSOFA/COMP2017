1. Describe how your exchange works.
First, I start to open the product file, which is argv[1], and print it out. I use a loop to initialize every trader in this exchange, then create a fifo (named pipe) and create a child process to exec into their own binary file. After all these initialization, I send sigusr1 to every trader with a loop to tell them market is open. Whenever I got a signal from any trader, I use sigaciton to get the pid of the sender. Then I find the trader with pid, and read its pipe to get its command and follow the instruction to do what they want me to do. Whenever I get a sigchld, which means there is a child process end, I unlink the pipe. Then free everything at the end. (I do not have time to change my signal handler, but I think I can create a buffer to store all the command, and deal all my command out of my signal handler)

2. Describe your design decisions for the trader and how it's fault-tolerant.
I open the pipe by the trader id, which is argv[1], then I make trader paused until it got a sigusr1 by the exchange. Then whenever I got a sigusr1, I’ll check is it “market sell”. If yes, I’ll check is its quantity >= 1000 or not, if yes, I’ll free everything and exit(0). If no for the quantity, I’ll place a opposite buy order immediately. I got no time to change my trader.c any more, if I can, I’ll add if I do not get “accepted” and “fill”, I’ll send the sigusr1 to the market again and again.

3. Describe your tests and how to run them.
For the E2E test, I created 3 trader file. One is for testing all the invalid command. The other two files is for testing how the matching order logic going. I use nanosleep for test to make them run separately. If I don’t make them run separately, all the order will be placed randomly, because they are the process of the market. However, I do not have enough time to do the unit test by Cmocka, because I thought we just need to choose one of them between unit test and e2e test (I don’t even know why I did think that way, since both of these tests are important for all programmer).